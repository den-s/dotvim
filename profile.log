FUNCTION  LightlineFileformat()
Called 24 times
Total time:   0.000104
 Self time:   0.000104

count  total (s)   self (s)
   24              0.000072   return winwidth(0) > 160 ? &fileformat : ''

FUNCTION  <SNR>143_is_modified_and_added()
Called 4 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    4              0.000012   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  <SNR>107_has_fresh_changes()
Called 2 times
Total time:   0.000103
 Self time:   0.000050

count  total (s)   self (s)
    2   0.000101   0.000048   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  <SNR>102_reset_summary()
Called 2 times
Total time:   0.000065
 Self time:   0.000025

count  total (s)   self (s)
    2   0.000064   0.000024   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>143_save_last_seen_change()
Called 2 times
Total time:   0.000057
 Self time:   0.000022

count  total (s)   self (s)
    2   0.000055   0.000020   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  <SNR>103_GetCounts()
Called 8 times
Total time:   0.000292
 Self time:   0.000292

count  total (s)   self (s)
    8              0.000104     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return s:CreateCountDict()
                                endif
                            
                                " Cache is cold, so manually ask for an update.
    8              0.000046     if !has_key(g:ale_buffer_info[a:buffer], 'count')
                                    call ale#statusline#Update(a:buffer, g:ale_buffer_info[a:buffer].loclist)
                                endif
                            
    8              0.000033     return g:ale_buffer_info[a:buffer].count

FUNCTION  gitgutter#hunk#increment_lines_added()
Called 14 times
Total time:   0.001318
 Self time:   0.000303

count  total (s)   self (s)
   14   0.000911   0.000132   let summary = gitgutter#hunk#summary(a:bufnr)
   14              0.000039   let summary[0] += a:count
   14   0.000358   0.000122   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  gitgutter#utility#cd_cmd()
Called 2 times
Total time:   0.001775
 Self time:   0.000115

count  total (s)   self (s)
    2   0.001187   0.000078   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() ? 'cd /d' : 'cd')
    2   0.000583   0.000032   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  <SNR>141_build_command()
Called 2 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    2              0.000007   if has('unix')
    2              0.000011     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  gitgutter#diff#parse_diff()
Called 2 times
Total time:   0.001296
 Self time:   0.000504

count  total (s)   self (s)
    2              0.000010   let hunks = []
   22              0.000107   for line in split(a:diff, '\n')
   20   0.001035   0.000243     let hunk_info = gitgutter#diff#parse_hunk(line)
   20              0.000038     if len(hunk_info) == 4
   20              0.000047       call add(hunks, hunk_info)
   20              0.000012     endif
   20              0.000012   endfor
    2              0.000003   return hunks

FUNCTION  ale#statusline#Count()
Called 8 times
Total time:   0.000505
 Self time:   0.000213

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
    8   0.000476   0.000184     return copy(s:GetCounts(a:buffer))

FUNCTION  gitgutter#utility#extension()
Called 2 times
Total time:   0.000267
 Self time:   0.000022

count  total (s)   self (s)
    2   0.000266   0.000021   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  <SNR>141_on_stdout_vim()
Called 20 times
Total time:   0.000187
 Self time:   0.000187

count  total (s)   self (s)
   20              0.000173   call add(self.stdoutbuffer, a:data)

FUNCTION  gitgutter#hunk#hunks()
Called 2 times
Total time:   0.000042
 Self time:   0.000021

count  total (s)   self (s)
    2   0.000040   0.000019   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  gitgutter#hunk#increment_lines_modified()
Called 6 times
Total time:   0.000358
 Self time:   0.000103

count  total (s)   self (s)
    6   0.000159   0.000036   let summary = gitgutter#hunk#summary(a:bufnr)
    6              0.000013   let summary[1] += a:count
    6   0.000178   0.000046   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>145_upsert_new_gitgutter_signs()
Called 2 times
Total time:   0.001462
 Self time:   0.001226

count  total (s)   self (s)
    2   0.000038   0.000017   let other_signs         = gitgutter#utility#getbufvar(a:bufnr, 'other_signs')
    2   0.000031   0.000015   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                            
                              " Handle special case where the first line is the site of two hunks:
                              " lines deleted above at the start of the file, and lines deleted
                              " immediately below.
    2              0.000013   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                let modified_lines = [[1, 'removed_above_and_below']] + a:modified_lines[2:]
                              else
    2              0.000003     let modified_lines = a:modified_lines
    2              0.000001   endif
                            
   42              0.000049   for line in modified_lines
   40              0.000069     let line_number = line[0]  " <number>
   40              0.000079     if index(other_signs, line_number) == -1  " don't clobber others' signs
   40   0.000525   0.000326       let name = s:highlight_name_for_change(line[1])
   40              0.000095       if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = s:next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . a:bufnr
                                  else  " update if sign has changed
   40              0.000088         let old_sign = old_gitgutter_signs[line_number]
   40              0.000071         if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . a:bufnr
                                    end
   40              0.000023       endif
   40              0.000019     endif
   40              0.000024   endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  <SNR>164_StopCursorTimer()
Called 2 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    2              0.000011     if s:cursor_timer != -1
                                    call timer_stop(s:cursor_timer)
                                    let s:cursor_timer = -1
                                endif

FUNCTION  gitgutter#diff#parse_hunk()
Called 20 times
Total time:   0.000792
 Self time:   0.000792

count  total (s)   self (s)
   20              0.000381   let matches = matchlist(a:line, s:hunk_re)
   20              0.000046   if len(matches) > 0
   20              0.000066     let from_line  = str2nr(matches[1])
   20              0.000076     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
   20              0.000055     let to_line    = str2nr(matches[3])
   20              0.000068     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
   20              0.000053     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  <SNR>143_is_added()
Called 20 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
   20              0.000051   return a:from_count == 0 && a:to_count > 0

FUNCTION  LightlineFilename()
Called 16 times
Total time:   0.001411
 Self time:   0.001241

count  total (s)   self (s)
   16              0.000092   let fname = expand('%:t')
   16   0.001290   0.001120   return fname == 'ControlP' && has_key(g:lightline, 'ctrlp_item') ? g:lightline.ctrlp_item : fname == '__Tagbar__' ? g:lightline.fname : fname =~ '__Gundo\|NERD_tree' ? '' : &ft == 'vimfiler' ? vimfiler#get_status_string() : &ft == 'unite' ? unite#get_status_string() : &ft == 'vimshell' ? vimshell#get_status_string() : ('' != LightlineReadonly() ? LightlineReadonly() . ' ' : '') . ('' != fname ? (winwidth(0) > 140 ? expand('%') : expand('%:t')) : '[No Name]') . ('' != LightlineModified() ? ' ' . LightlineModified() : '')

FUNCTION  fugitive#ReloadStatus()
Called 2 times
Total time:   0.002310
 Self time:   0.002310

count  total (s)   self (s)
    2              0.000018   if exists('s:reloading_status')
                                return
                              endif
    2              0.000002   try
    2              0.000022     let s:reloading_status = 1
    2              0.000009     let mytab = tabpagenr()
   22              0.000173     for tab in [mytab] + range(1,tabpagenr('$'))
   46              0.000167       for winnr in range(1,tabpagewinnr(tab,'$'))
   26              0.000258         if getbufvar(tabpagebuflist(tab)[winnr-1],'fugitive_type') ==# 'index'
                                      execute 'tabnext '.tab
                                      if winnr != winnr()
                                        execute winnr.'wincmd w'
                                        let restorewinnr = 1
                                      endif
                                      try
                                        if !&modified
                                          call fugitive#BufReadStatus()
                                        endif
                                      finally
                                        if exists('restorewinnr')
                                          wincmd p
                                        endif
                                        execute 'tabnext '.mytab
                                      endtry
                                    endif
   26              0.000033       endfor
   20              0.000032     endfor
    2              0.000015   finally
    2              0.000008     unlet! s:reloading_status
    2              0.000003   endtry

FUNCTION  <SNR>143_process_modified()
Called 2 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
    2              0.000002   let offset = 0
    6              0.000009   while offset < a:to_count
    4              0.000008     let line_number = a:to_line + offset
    4              0.000024     call add(a:modifications, [line_number, 'modified'])
    4              0.000011     let offset += 1
    4              0.000004   endwhile

FUNCTION  <SNR>80_exists_file()
Called 6 times
Total time:   0.002473
 Self time:   0.000451

count  total (s)   self (s)
    6   0.002469   0.000447   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  LightlineAle()
Called 8 times
Total time:   0.000742
 Self time:   0.000237

count  total (s)   self (s)
    8   0.000633   0.000128   let counts = ale#statusline#Count(bufnr(''))
    8              0.000028   let errors = counts.error > 0 ? 'E:'.counts.error : ''
    8              0.000028   let warnings = counts.warning > 0 ? (errors !=# '' ? ' W:'.counts.warning : 'W:'.counts.warning) : ''
    8              0.000023   return errors.warnings

FUNCTION  gitgutter#init_buffer()
Called 2 times
Total time:   0.002613
 Self time:   0.000215

count  total (s)   self (s)
    2   0.002144   0.000032   if gitgutter#utility#is_active(a:bufnr)
    2   0.000391   0.000105     let p = gitgutter#utility#repo_path(a:bufnr, 0)
    2              0.000033     if type(p) != s:t_string || empty(p)
                                  call gitgutter#utility#set_repo_path(a:bufnr)
                                  call s:setup_maps()
                                endif
    2              0.000002   endif

FUNCTION  gitgutter#diff#run_diff()
Called 2 times
Total time:   0.029392
 Self time:   0.002276

count  total (s)   self (s)
    2   0.000099   0.000024   while gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                sleep 5m
                              endwhile
                            
    2   0.000074   0.000020   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
                              endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    2              0.000002   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    2              0.000010   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
    2   0.000285   0.000018   let extension = gitgutter#utility#extension(a:bufnr)
    2              0.000005   if !empty(extension)
    2              0.000007     let buff_file .= '.'.extension
    2              0.000001   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    2   0.002916   0.000273   call s:write_buffer(a:bufnr, buff_file)
                            
    2              0.000069   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
    2              0.000048     let from_file = s:temp_from.'.'.a:bufnr
                            
    2              0.000031     if !empty(extension)
    2              0.000010       let from_file .= '.'.extension
    2              0.000005     endif
                            
                                " Write file from index to temporary file.
    2   0.001075   0.000094     let index_name = g:gitgutter_diff_base.':'.gitgutter#utility#repo_path(a:bufnr, 1)
    2              0.000037     let cmd .= g:gitgutter_git_executable.' --no-pager show '.index_name.' > '.from_file.' && '
                            
    2              0.000005   elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
                              endif
                            
                              " Call git-diff.
    2              0.000020   let cmd .= g:gitgutter_git_executable.' --no-pager '.g:gitgutter_git_args
    2              0.000005   if s:c_flag
    2              0.000135     let cmd .= ' -c "diff.autorefreshindex=0"'
    2              0.000073     let cmd .= ' -c "diff.noprefix=false"'
    2              0.000041     let cmd .= ' -c "core.safecrlf=false"'
    2              0.000007   endif
    2              0.000107   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    2              0.000030   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    2   0.000425   0.000263     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    2              0.000007   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    2              0.000048   let cmd .= ' || exit 0'
                            
    2              0.000009   let cmd .= ')'
                            
    2   0.001832   0.000057   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    2   0.000052   0.000037   if g:gitgutter_async && gitgutter#async#available()
    2   0.021622   0.000478     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    2              0.000063     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  gitgutter#hunk#increment_lines_removed()
Called 4 times
Total time:   0.000268
 Self time:   0.000076

count  total (s)   self (s)
    4   0.000167   0.000032   let summary = gitgutter#hunk#summary(a:bufnr)
    4              0.000010   let summary[2] += a:count
    4   0.000088   0.000031   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>107_reset_tick()
Called 116 times
Total time:   0.018706
 Self time:   0.006177

count  total (s)   self (s)
  116   0.018162   0.005633   call gitgutter#utility#setbufvar(a:bufnr, 'tick', 0)

FUNCTION  <SNR>80_dir()
Called 8 times
Total time:   0.004662
 Self time:   0.002463

count  total (s)   self (s)
    8   0.004654   0.002455   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  gitgutter#utility#is_active()
Called 6 times
Total time:   0.007414
 Self time:   0.000433

count  total (s)   self (s)
    6   0.007395   0.000414   return g:gitgutter_enabled && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  LightlineMode()
Called 16 times
Total time:   0.001028
 Self time:   0.000852

count  total (s)   self (s)
   16              0.000124   let fname = expand('%:t')
   16   0.000863   0.000687   return fname == '__Tagbar__' ? 'Tagbar' : fname == 'ControlP' ? 'CtrlP' : fname == '__Gundo__' ? 'Gundo' : fname == '__Gundo_Preview__' ? 'Gundo Preview' : fname =~ 'NERD_tree' ? 'NERDTree' : &ft == 'unite' ? 'Unite' : &ft == 'vimfiler' ? 'VimFiler' : &ft == 'vimshell' ? 'VimShell' : winwidth(0) > 60 ? lightline#mode() : ''

FUNCTION  <SNR>80_winshell()
Called 2 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    2              0.000038   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  fugitive#head()
Called 24 times
Total time:   0.004953
 Self time:   0.000646

count  total (s)   self (s)
   24              0.000125   if !exists('b:git_dir')
                                return ''
                              endif
                            
   24   0.004602   0.000295   return fugitive#Head(a:0 ? a:1 : 0)

FUNCTION  gitgutter#utility#getbufvar()
Called 58 times
Total time:   0.001466
 Self time:   0.001466

count  total (s)   self (s)
   58              0.000882   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
   58              0.000260   if has_key(dict, a:varname)
   58              0.000145     return dict[a:varname]
                              else
                                if a:0
                                  return a:1
                                endif
                              endif

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 2 times
Total time:   0.000386
 Self time:   0.000352

count  total (s)   self (s)
    2              0.000029     let l:buffer = bufnr('')
                            
    2              0.000014     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    2              0.000020     if mode(1) isnot# 'n'
                                    return
                                endif
                            
    2   0.000156   0.000122     call s:StopCursorTimer()
                            
    2              0.000031     let l:pos = getcurpos()[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
    2              0.000010     if l:pos != s:last_pos
                                    let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
                                    let s:last_pos = l:pos
                                    let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
                                endif

FUNCTION  <SNR>145_obsolete_gitgutter_signs_to_remove()
Called 2 times
Total time:   0.000561
 Self time:   0.000533

count  total (s)   self (s)
    2              0.000004   let signs_to_remove = []  " list of [<id (number)>, ...]
    2              0.000003   let remove_all_signs = 1
    2   0.000046   0.000018   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
   42              0.000114   for line_number in keys(old_gitgutter_signs)
   40              0.000146     if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
   40              0.000046       let remove_all_signs = 0
   40              0.000029     endif
   40              0.000025   endfor
    2              0.000004   let s:remove_all_old_signs = remove_all_signs
    2              0.000002   return signs_to_remove

FUNCTION  <SNR>143_write_buffer()
Called 2 times
Total time:   0.002643
 Self time:   0.002643

count  total (s)   self (s)
    2              0.000083   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    2              0.000009   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif
                            
    2              0.000006   let fenc = getbufvar(a:bufnr, '&fileencoding')
    2              0.000004   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
                              endif
                            
    2              0.000005   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
                              endif
                            
    2              0.002505   call writefile(bufcontents, a:file)

FUNCTION  gitgutter#hunk#set_hunks()
Called 2 times
Total time:   0.000307
 Self time:   0.000041

count  total (s)   self (s)
    2   0.000220   0.000019   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    2   0.000084   0.000019   call s:reset_summary(a:bufnr)

FUNCTION  <SNR>80_not_git_dir()
Called 6 times
Total time:   0.004410
 Self time:   0.000299

count  total (s)   self (s)
    6   0.004404   0.000293   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  <SNR>143_process_removed()
Called 4 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    4              0.000005   if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
                              else
    4              0.000011     call add(a:modifications, [a:to_line, 'removed'])
    4              0.000002   endif

FUNCTION  LightlineGitGutterHunks()
Called 16 times
Total time:   0.002820
 Self time:   0.001456

count  total (s)   self (s)
   16              0.000219   if ! exists('*GitGutterGetHunkSummary') || ! get(g:, 'gitgutter_enabled', 0) || winwidth('.') <= 90
                                return ''
                              endif
   16              0.000056   let symbols = ['+', '~', '-']
   16   0.001613   0.000249   let hunks = GitGutterGetHunkSummary()
   16              0.000031   let ret = []
   64              0.000176   for i in [0, 1, 2]
                                " if hunks[i] > 0
   48              0.000298       call add(ret, symbols[i] . hunks[i])
                                " endif
   48              0.000046   endfor
   16              0.000094   return winwidth(0) > 70 ? join(ret, ' ') : ''

FUNCTION  LightlineReadonly()
Called 16 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
   16              0.000046   return &readonly ? '' : ''

FUNCTION  LightlineFugitive()
Called 24 times
Total time:   0.006640
 Self time:   0.001687

count  total (s)   self (s)
   24              0.000046   try
   24              0.001084     if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
   24              0.000065       let mark = ''  " edit here for cool mark
   24   0.005196   0.000243       let branch = fugitive#head()
   24              0.000107       return branch !=# '' ? mark.branch : ''
                                endif
                              catch
                              endtry
                              return ''

FUNCTION  LightlineFileencoding()
Called 16 times
Total time:   0.000210
 Self time:   0.000210

count  total (s)   self (s)
   16              0.000186   return winwidth(0) > 160 ? (&fenc !=# '' ? &fenc : &enc) : ''

FUNCTION  gitgutter#async#available()
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000005   return s:available

FUNCTION  <SNR>143_process_added()
Called 10 times
Total time:   0.000548
 Self time:   0.000548

count  total (s)   self (s)
   10              0.000025   let offset = 0
   24              0.000061   while offset < a:to_count
   14              0.000049     let line_number = a:to_line + offset
   14              0.000237     call add(a:modifications, [line_number, 'added'])
   14              0.000035     let offset += 1
   14              0.000015   endwhile

FUNCTION  lightline#link()
Called 8 times
Total time:   0.000253
 Self time:   0.000253

count  total (s)   self (s)
    8              0.000171   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
    8              0.000039   if s:mode == mode
    8              0.000015     return ''
                              endif
                              let s:mode = mode
                              if !has_key(s:highlight, mode)
                                call lightline#highlight(mode)
                              endif
                              let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
                              for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
                                for [i, t] in map(range(0, l), '[v:val, 0]') + types
                                  if i != l
                                    exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
                                  endif
                                  for [j, s] in map(range(0, l), '[v:val, 0]') + types
                                    if i + 1 == j || t || s && i != l
                                      exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
                                    endif
                                  endfor
                                endfor
                              endfor
                              exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
                              return ''

FUNCTION  <SNR>145_highlight_name_for_change()
Called 40 times
Total time:   0.000199
 Self time:   0.000199

count  total (s)   self (s)
   40              0.000065   if a:text ==# 'added'
   28              0.000031     return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
    4              0.000005     return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
    8              0.000008     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  gitgutter#diff#process_hunks()
Called 2 times
Total time:   0.005721
 Self time:   0.000322

count  total (s)   self (s)
    2              0.000003   let modified_lines = []
   22              0.000031   for hunk in a:hunks
   20   0.005643   0.000244     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
   20              0.000018   endfor
    2              0.000002   return modified_lines

FUNCTION  <SNR>143_is_modified()
Called 6 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    6              0.000018   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  gitgutter#debug#log()
Called 4 times
Total time:   0.000215
 Self time:   0.000215

count  total (s)   self (s)
    4              0.000018   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  <SNR>143_process_hunk()
Called 20 times
Total time:   0.005399
 Self time:   0.002028

count  total (s)   self (s)
   20              0.000074   let modifications = []
   20              0.000057   let from_line  = a:hunk[0]
   20              0.000043   let from_count = a:hunk[1]
   20              0.000036   let to_line    = a:hunk[2]
   20              0.000042   let to_count   = a:hunk[3]
                            
   20   0.000338   0.000274   if s:is_added(from_count, to_count)
   10   0.000712   0.000164     call s:process_added(modifications, from_count, to_count, to_line)
   10   0.001015   0.000149     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
   10              0.000026   elseif s:is_removed(from_count, to_count)
    4   0.000073   0.000033     call s:process_removed(modifications, from_count, to_count, to_line)
    4   0.000310   0.000042     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
    4              0.000009   elseif s:is_modified(from_count, to_count)
    2   0.000095   0.000017     call s:process_modified(modifications, from_count, to_count, to_line)
    2   0.000133   0.000017     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
    2              0.000004   elseif s:is_modified_and_added(from_count, to_count)
    4   0.000708   0.000072     call s:process_modified_and_added(modifications, from_count, to_count, to_line)
    4   0.000497   0.000045     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
    4   0.000274   0.000032     call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
    4              0.000015   elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
                              endif
   20              0.000023   return modifications

FUNCTION  <SNR>143_process_modified_and_added()
Called 4 times
Total time:   0.000636
 Self time:   0.000636

count  total (s)   self (s)
    4              0.000012   let offset = 0
    8              0.000016   while offset < a:from_count
    4              0.000012     let line_number = a:to_line + offset
    4              0.000019     call add(a:modifications, [line_number, 'modified'])
    4              0.000007     let offset += 1
    4              0.000004   endwhile
   18              0.000029   while offset < a:to_count
   14              0.000040     let line_number = a:to_line + offset
   14              0.000372     call add(a:modifications, [line_number, 'added'])
   14              0.000049     let offset += 1
   14              0.000017   endwhile

FUNCTION  gitgutter#all()
Called 2 times
Total time:   0.125461
 Self time:   0.072763

count  total (s)   self (s)
    2              0.000033   let visible = tabpagebuflist()
                            
 1378              0.006756   for bufnr in range(1, bufnr('$') + 1)
 1376              0.004436     if buflisted(bufnr)
  124              0.024050       let file = expand('#'.bufnr.':p')
  124              0.000959       if !empty(file)
  118              0.000859         if index(visible, bufnr) != -1
    2   0.002659   0.000046           call gitgutter#init_buffer(bufnr)
    2   0.031683   0.000304           call gitgutter#process_buffer(bufnr, a:force)
    2              0.000010         elseif a:force
  116   0.023076   0.004370           call s:reset_tick(bufnr)
  116              0.000175         endif
  118              0.000106       endif
  124              0.000119     endif
 1376              0.001552   endfor

FUNCTION  gitgutter#utility#shellescape()
Called 12 times
Total time:   0.001024
 Self time:   0.000985

count  total (s)   self (s)
   12              0.000815   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   10              0.000071     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
    2              0.000008     return shellescape(a:arg)
                              endif

FUNCTION  lightline#mode()
Called 16 times
Total time:   0.000176
 Self time:   0.000176

count  total (s)   self (s)
   16              0.000140   return get(s:lightline.mode_map, mode(), '')

FUNCTION  fugitive#Head()
Called 24 times
Total time:   0.004307
 Self time:   0.004307

count  total (s)   self (s)
   24              0.000342   let dir = a:0 > 1 ? a:2 : get(b:, 'git_dir', '')
   24              0.001638   if empty(dir) || !filereadable(dir . '/HEAD')
                                return ''
                              endif
   24              0.001248   let head = readfile(dir . '/HEAD')[0]
   24              0.000339   if head =~# '^ref: '
   24              0.000581     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  gitgutter#sign#update_signs()
Called 2 times
Total time:   0.006709
 Self time:   0.000230

count  total (s)   self (s)
    2   0.004465   0.000048   call s:find_current_signs(a:bufnr)
                            
    2              0.000067   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
    2   0.000590   0.000029   let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
    2              0.000006   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
    2              0.000002   if flicker_possible
                                call s:add_dummy_sign(a:bufnr)
                              endif
                            
    2   0.000058   0.000019   call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
    2   0.001490   0.000028   call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
                            
    2              0.000002   if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(a:bufnr, 0)
                              endif

FUNCTION  gitgutter#utility#setbufvar()
Called 152 times
Total time:   0.013604
 Self time:   0.013604

count  total (s)   self (s)
  152              0.000727   let buffer = +a:buffer
  152              0.006915   let dict = get(getbufvar(buffer, '', {}), 'gitgutter', {})
  152              0.000869   let needs_setting = empty(dict)
  152              0.003092   let dict[a:varname] = a:val
  152              0.000309   if needs_setting
                                call setbufvar(buffer, 'gitgutter', dict)
                              endif

FUNCTION  <SNR>143_is_removed()
Called 10 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
   10              0.000025   return a:from_count > 0 && a:to_count == 0

FUNCTION  gitgutter#process_buffer()
Called 4 times
Total time:   0.035688
 Self time:   0.000891

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    4   0.005380   0.000078   if gitgutter#utility#is_active(a:bufnr)
    4   0.000156   0.000053     if a:force || s:has_fresh_changes(a:bufnr)
                            
    2              0.000004       let diff = ''
    2              0.000003       try
    2   0.029916   0.000524         let diff = gitgutter#diff#run_diff(a:bufnr, 'index', 0)
    2              0.000034       catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
    2              0.000007       if diff != 'async'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
    2              0.000001     endif
    4              0.000003   endif

FUNCTION  gitgutter#utility#repo_path()
Called 8 times
Total time:   0.001396
 Self time:   0.000662

count  total (s)   self (s)
    8   0.000965   0.000554   let p = gitgutter#utility#getbufvar(a:bufnr, 'path')
    8   0.000407   0.000084   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  gitgutter#utility#windows()
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    2              0.000041   return has('win64') || has('win32') || has('win16')

FUNCTION  gitgutter#hunk#summary()
Called 40 times
Total time:   0.001857
 Self time:   0.000941

count  total (s)   self (s)
   40   0.001802   0.000886   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  LightlineFiletype()
Called 16 times
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
   16              0.000096   return winwidth(0) > 160 ? (&filetype !=# '' ? &filetype : 'no ft') : ''

FUNCTION  GitGutterGetHunkSummary()
Called 16 times
Total time:   0.001364
 Self time:   0.000544

count  total (s)   self (s)
   16   0.001334   0.000514   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  LightLineGitversion()
Called 16 times
Total time:   0.000585
 Self time:   0.000585

count  total (s)   self (s)
   16              0.000079   let fullname = expand('%')
   16              0.000029   let gitversion = ''
   16              0.000127   if fullname =~? 'fugitive://.*/\.git//0/.*'
                                let gitversion = 'git index'
                              elseif fullname =~? 'fugitive://.*/\.git//2/.*'
                                let gitversion = 'git target'
                              elseif fullname =~? 'fugitive://.*/\.git//3/.*'
                                let gitversion = 'git merge'
                              elseif &diff == 1
                                let gitversion = 'working copy'
                              endif
   16              0.000022   return gitversion

FUNCTION  <SNR>80_abs_path()
Called 18 times
Total time:   0.004921
 Self time:   0.004921

count  total (s)   self (s)
   18              0.004707   let p = resolve(expand('#'.a:bufnr.':p'))
   18              0.000172   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  gitgutter#async#execute()
Called 2 times
Total time:   0.021144
 Self time:   0.021009

count  total (s)   self (s)
    2   0.000143   0.000042   call gitgutter#debug#log('[async] '.a:cmd)
                            
    2              0.000078   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    2   0.000059   0.000025   let command = s:build_command(a:cmd)
                            
    2              0.000010   if has('nvim')
                                call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
    2              0.020722     call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
    2              0.000047   endif

FUNCTION  gitgutter#diff#handler()
Called 2 times
Total time:   0.014499
 Self time:   0.000253

count  total (s)   self (s)
    2   0.000152   0.000038   call gitgutter#debug#log(a:diff)
                            
    2              0.000009   if !bufexists(a:bufnr)
                                return
                              endif
                            
    2   0.001648   0.000045   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    2   0.005796   0.000033   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    2              0.000004   let signs_count = len(modified_lines)
    2              0.000006   if signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
                              else
    2              0.000004     if g:gitgutter_signs || g:gitgutter_highlight_lines
    2   0.006746   0.000037       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    2              0.000000     endif
    2              0.000002   endif
                            
    2   0.000074   0.000017   call s:save_last_seen_change(a:bufnr)
    2              0.000015   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
                              endif

FUNCTION  <lambda>1()
Called 63 times
Total time:   0.001110
 Self time:   0.001110

count  total (s)   self (s)
   63              0.000838 return 0

FUNCTION  <SNR>141_on_exit_vim()
Called 2 times
Total time:   0.014621
 Self time:   0.000122

count  total (s)   self (s)
    2   0.014619   0.000120   call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))

FUNCTION  CtrlPMark()
Called 16 times
Total time:   0.000320
 Self time:   0.000320

count  total (s)   self (s)
   16              0.000151   if expand('%:t') =~ 'ControlP' && has_key(g:lightline, 'ctrlp_item')
                                call lightline#link('iR'[g:lightline.ctrlp_regex])
                                return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item , g:lightline.ctrlp_next], 0)
                              else
   16              0.000012     return ''
                              endif

FUNCTION  <SNR>80_unc_path()
Called 2 times
Total time:   0.001066
 Self time:   0.000072

count  total (s)   self (s)
    2   0.001063   0.000069   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  LightlineModified()
Called 16 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
   16              0.000083   return winwidth(0) > 70 ? (&modified > 0 ? '[+]' : '') : ''

FUNCTION  <SNR>80_is_file_buffer()
Called 6 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
    6              0.000087   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  <SNR>145_find_current_signs()
Called 2 times
Total time:   0.004417
 Self time:   0.004043

count  total (s)   self (s)
    2              0.000007   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
    2              0.000004   let other_signs = []      " [<line_number (number),...]
    2              0.000003   let dummy_sign_placed = 0
                            
    2              0.000007   redir => signs
    2              0.000067     silent execute "sign place buffer=" . a:bufnr
    2              0.000007   redir END
                            
   42              0.000601   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
   40              0.000608     let components  = split(sign_line)
   40              0.000491     let name        = split(components[2], '=')[1]
   40              0.000265     if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
   40              0.000359       let line_number = str2nr(split(components[0], '=')[1])
   40              0.000157       if name =~# 'GitGutter'
   40              0.000287         let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
   40              0.000138         if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
   40              0.000306         let gitgutter_signs[line_number] = {'id': id, 'name': name}
   40              0.000036       else
                                    call add(other_signs, line_number)
                                  endif
   40              0.000029     end
   40              0.000026   endfor
                            
    2   0.000069   0.000025   call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', dummy_sign_placed)
    2   0.000319   0.000018   call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', gitgutter_signs)
    2   0.000045   0.000016   call gitgutter#utility#setbufvar(a:bufnr, 'other_signs', other_signs)

FUNCTION  <SNR>145_remove_signs()
Called 2 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    2              0.000008   if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(a:bufnr, 'other_signs'))
                                let dummy_sign_present = gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign')
                                execute "sign unplace * buffer=" . a:bufnr
                                if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . a:bufnr
                                endif
                              else
    2              0.000003     for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
    2              0.000001   endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    2   0.125461   0.072763  gitgutter#all()
    4   0.035688   0.000891  gitgutter#process_buffer()
    2   0.029392   0.002276  gitgutter#diff#run_diff()
    2   0.021144   0.021009  gitgutter#async#execute()
  116   0.018706   0.006177  <SNR>107_reset_tick()
    2   0.014621   0.000122  <SNR>141_on_exit_vim()
    2   0.014499   0.000253  gitgutter#diff#handler()
  152   0.013604             gitgutter#utility#setbufvar()
    6   0.007414   0.000433  gitgutter#utility#is_active()
    2   0.006709   0.000230  gitgutter#sign#update_signs()
   24   0.006640   0.001687  LightlineFugitive()
    2   0.005721   0.000322  gitgutter#diff#process_hunks()
   20   0.005399   0.002028  <SNR>143_process_hunk()
   24   0.004953   0.000646  fugitive#head()
   18   0.004921             <SNR>80_abs_path()
    8   0.004662   0.002463  <SNR>80_dir()
    2   0.004417   0.004043  <SNR>145_find_current_signs()
    6   0.004410   0.000299  <SNR>80_not_git_dir()
   24   0.004307             fugitive#Head()
   16   0.002820   0.001456  LightlineGitGutterHunks()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    2   0.125461   0.072763  gitgutter#all()
    2   0.021144   0.021009  gitgutter#async#execute()
  152              0.013604  gitgutter#utility#setbufvar()
  116   0.018706   0.006177  <SNR>107_reset_tick()
   18              0.004921  <SNR>80_abs_path()
   24              0.004307  fugitive#Head()
    2   0.004417   0.004043  <SNR>145_find_current_signs()
    2              0.002643  <SNR>143_write_buffer()
    8   0.004662   0.002463  <SNR>80_dir()
    2              0.002310  fugitive#ReloadStatus()
    2   0.029392   0.002276  gitgutter#diff#run_diff()
   20   0.005399   0.002028  <SNR>143_process_hunk()
   24   0.006640   0.001687  LightlineFugitive()
   58              0.001466  gitgutter#utility#getbufvar()
   16   0.002820   0.001456  LightlineGitGutterHunks()
   16   0.001411   0.001241  LightlineFilename()
    2   0.001462   0.001226  <SNR>145_upsert_new_gitgutter_signs()
   63              0.001110  <lambda>1()
   12   0.001024   0.000985  gitgutter#utility#shellescape()
   40   0.001857   0.000941  gitgutter#hunk#summary()

