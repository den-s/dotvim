FUNCTION  LightlineFileformat()
    Defined: ~/.vim/conf/lightline.vim:128
Called 33 times
Total time:   0.000191
 Self time:   0.000191

count  total (s)   self (s)
   33              0.000165   return winwidth(0) > 160 ? &fileformat : ''

FUNCTION  <SNR>78_has_any()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:223
Called 4 times
Total time:   0.000179
 Self time:   0.000179

count  total (s)   self (s)
   18              0.000038   for key in a:keys
   14              0.000055     if has_key(a:dict, key)
                                  return 1
   14              0.000010     endif
   18              0.000020   endfor
    4              0.000006   return 0

FUNCTION  <SNR>119_get_git_root()
    Defined: ~/.vim/vim-plug/fzf.vim/autoload/fzf/vim.vim:531
Called 2 times
Total time:   0.046102
 Self time:   0.000822

count  total (s)   self (s)
    2   0.046075   0.000795   let root = split(system('git rev-parse --show-toplevel'), '\n')[0]
    2              0.000019   return v:shell_error ? '' : root

FUNCTION  <SNR>119_merge_opts()
    Defined: ~/.vim/vim-plug/fzf.vim/autoload/fzf/vim.vim:69
Called 2 times
Total time:   0.000106
 Self time:   0.000082

count  total (s)   self (s)
    2   0.000101   0.000077   return s:extend_opts(a:dict, a:eopts, 0)

FUNCTION  sy#verbose()
    Defined: ~/.vim/vim-plug/vim-signify/autoload/sy.vim:126
Called 3 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
    3              0.000009   if &verbose
                                if type(a:msg) == type([])
                                  for msg in a:msg
                                    echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), msg)
                                  endfor
                                else
                                  echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), a:msg)
                                endif
    3              0.000003   endif

FUNCTION  <SNR>78_upgrade()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:197
Called 2 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    2              0.000025   let copy = copy(a:dict)
    2              0.000009   if has_key(copy, 'tmux')
                                let copy.down = remove(copy, 'tmux')
    2              0.000002   endif
    2              0.000009   if has_key(copy, 'tmux_height')
                                let copy.down = remove(copy, 'tmux_height')
    2              0.000002   endif
    2              0.000009   if has_key(copy, 'tmux_width')
                                let copy.right = remove(copy, 'tmux_width')
    2              0.000002   endif
    2              0.000003   return copy

FUNCTION  LightlineFileencoding()
    Defined: ~/.vim/conf/lightline.vim:136
Called 22 times
Total time:   0.000319
 Self time:   0.000319

count  total (s)   self (s)
   22              0.000297   return winwidth(0) > 160 ? (&fenc !=# '' ? &fenc : &enc) : ''

FUNCTION  <SNR>78_validate_layout()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:296
Called 2 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    4              0.000013   for key in keys(a:layout)
    2              0.000007     if index(s:layout_keys, key) < 0
                                  throw printf('Invalid entry in g:fzf_layout: %s (allowed: %s)%s', key, join(s:layout_keys, ', '), key == 'options' ? '. Use $FZF_DEFAULT_OPTS.' : '')
    2              0.000002     endif
    4              0.000004   endfor
    2              0.000002   return a:layout

FUNCTION  <SNR>78_present()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:461
Called 4 times
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
   12              0.000030   for key in a:000
   10              0.000050     if !empty(get(a:dict, key, ''))
    2              0.000003       return 1
    8              0.000005     endif
   10              0.000007   endfor
    2              0.000002   return 0

FUNCTION  lightline#link()
    Defined: ~/.vim/vim-plug/lightline.vim/autoload/lightline.vim:217
Called 11 times
Total time:   0.001357
 Self time:   0.001357

count  total (s)   self (s)
   11              0.000214   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
   11              0.000044   if s:mode ==# mode
   10              0.000022     return ''
    1              0.000001   endif
    1              0.000002   let s:mode = mode
    1              0.000003   if !has_key(s:highlight, mode)
                                call lightline#highlight(mode)
    1              0.000001   endif
    1              0.000018   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
    3              0.000012   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
   13              0.000035     for [i, t] in map(range(0, l), '[v:val, 0]') + types
   11              0.000012       if i != l
    9              0.000081         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
   11              0.000007       endif
   72              0.000191       for [j, s] in map(range(0, l), '[v:val, 0]') + types
   61              0.000119         if i + 1 == j || t || s && i != l
   25              0.000235           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
   61              0.000045         endif
   72              0.000050       endfor
   13              0.000008     endfor
    3              0.000004   endfor
    1              0.000007   exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
    1              0.000002   return ''

FUNCTION  <SNR>109_skip()
    Defined: ~/.vim/vim-plug/vim-signify/autoload/sy.vim:148
Called 3 times
Total time:   0.000231
 Self time:   0.000231

count  total (s)   self (s)
    3              0.000206   if getbufvar(a:bufnr, '&diff') || !filereadable(a:path)
    3              0.000015     return 1
                              endif
                            
                              if exists('g:signify_skip_filetype')
                                if has_key(g:signify_skip_filetype, getbufvar(a:bufnr, '&filetype'))
                                  return 1
                                elseif has_key(g:signify_skip_filetype, 'help') && getbufvar(a:bufnr, '&buftype') == 'help'
                                  return 1
                                endif
                              endif
                            
                              if exists('g:signify_skip_filename') && has_key(g:signify_skip_filename, a:path)
                                return 1
                              endif
                            
                              " DEPRECATED: Use g:signify_skip.pattern instead.
                              if exists('g:signify_skip_filename_pattern')
                                for pattern in g:signify_skip_filename_pattern
                                  if a:path =~ pattern
                                    return 1
                                  endif
                                endfor
                              endif
                            
                              if exists('g:signify_skip')
                                if has_key(g:signify_skip, 'pattern')
                                  for pattern in g:signify_skip.pattern
                                    if a:path =~ pattern
                                      return 1
                                    endif
                                  endfor
                                endif
                              endif
                            
                              return 0

FUNCTION  LightlineHunks()
    Defined: ~/.vim/conf/lightline.vim:164
Called 22 times
Total time:   0.002171
 Self time:   0.001721

count  total (s)   self (s)
   22              0.000169   let symbols = ['+', '-', '~']
   22   0.001103   0.000653   let [added, modified, removed] = sy#repo#get_stats()
   22              0.000201   let stats = [added, removed, modified]  " reorder
   22              0.000067   let hunkline = ''
                            
   22              0.000093   if stats != [-1, -1, -1]
                                for i in range(3)
                                  let hunkline .= printf('%s%s ', symbols[i], stats[i])
                                endfor
                                return winwidth(0) > 70 ? (hunkline) : ''
   22              0.000028   endif
                            
   22              0.000031   return ''

FUNCTION  <SNR>109_get_path()
    Defined: ~/.vim/vim-plug/vim-signify/autoload/sy.vim:139
Called 3 times
Total time:   0.000783
 Self time:   0.000783

count  total (s)   self (s)
    3              0.000680   let path = resolve(fnamemodify(bufname(a:bufnr), ':p'))
    3              0.000042   if has('win32')
                                let path = substitute(path, '\v^(\w):\\\\', '\1:\\', '')
    3              0.000007   endif
    3              0.000020   return path

FUNCTION  sy#start()
    Defined: ~/.vim/vim-plug/vim-signify/autoload/sy.vim:7
Called 3 times
Total time:   0.001640
 Self time:   0.000539

count  total (s)   self (s)
    3              0.000012   if g:signify_locked
                                call sy#verbose('Locked.')
                                return
    3              0.000006   endif
                            
    3              0.000037   let bufnr = a:0 && has_key(a:1, 'bufnr') ? a:1.bufnr : bufnr('')
    3              0.000026   let sy = getbufvar(bufnr, 'sy')
                            
    3              0.000011   if empty(sy)
    3   0.000920   0.000137     let path = s:get_path(bufnr)
    3   0.000384   0.000153     if s:skip(bufnr, path)
    3   0.000188   0.000101       call sy#verbose('Skip file: '. path)
    3              0.000004       return
                                endif
                                call sy#verbose('Register new file: '. path)
                                let new_sy = { 'path':       path, 'buffer':     bufnr, 'active':     0, 'detecting':  0, 'vcs':        [], 'hunks':      [], 'signid':     0x100, 'updated_by': '', 'stats':      [-1, -1, -1], 'info':       {    'dir':  fnamemodify(path, ':p:h'),    'path': sy#util#escape(path),    'file': sy#util#escape(fnamemodify(path, ':t')) }}
                                call setbufvar(bufnr, 'sy', new_sy)
                                if get(g:, 'signify_disable_by_default')
                                  call sy#verbose('Disabled by default.')
                                  return
                                endif
                                let new_sy.active = 1
                                call setbufvar(bufnr, 'sy', new_sy)
                                call sy#repo#detect(bufnr)
                              elseif has('vim_starting')
                                call sy#verbose("Don't run Sy more than once during startup.")
                                return
                              elseif !sy.active
                                call sy#verbose('Inactive buffer.')
                                return
                              elseif empty(sy.vcs)
                                if get(sy, 'retry')
                                  let sy.retry = 0
                                  call sy#verbose('Redetecting VCS.')
                                  call sy#repo#detect(sy.buffer)
                                else
                                  if get(sy, 'detecting')
                                    call sy#verbose('Detection is already in progress.')
                                  else
                                    call sy#verbose('No VCS found. Disabling.')
                                    call sy#disable(sy.buffer)
                                  endif
                                endif
                              else
                                for vcs in sy.vcs
                                  let job_id = getbufvar(sy.buffer, 'sy_job_id_'. vcs, 0)
                                  if type(job_id) != type(0) || job_id > 0
                                    call sy#verbose('Update is already in progress.', vcs)
                                  else
                                    call sy#verbose('Updating signs.', vcs)
                                    call sy#repo#get_diff(sy.buffer, vcs, function('sy#sign#set_signs'))
                                  endif
                                endfor
                              endif

FUNCTION  <SNR>119_fzf()
    Defined: ~/.vim/vim-plug/fzf.vim/autoload/fzf/vim.vim:200
Called 2 times
Total time:   1.961416
 Self time:   0.000406

count  total (s)   self (s)
    2              0.000016   let [extra, bang] = [{}, 0]
    2              0.000008   if len(a:extra) <= 1
    2              0.000014     let first = get(a:extra, 0, 0)
    2              0.000020     if type(first) == s:TYPE.dict
                                  let extra = first
    2              0.000003     else
    2              0.000004       let bang = first
    2              0.000002     endif
                              elseif len(a:extra) == 2
                                let [extra, bang] = a:extra
                              else
                                throw 'invalid number of arguments'
    2              0.000003   endif
                            
    2              0.000014   let eopts  = has_key(extra, 'options') ? remove(extra, 'options') : ''
    2              0.000015   let merged = extend(copy(a:opts), extra)
    2   0.000192   0.000086   call s:merge_opts(merged, eopts)
    2   1.961087   0.000183   return fzf#run(s:wrap(a:name, merged, bang))

FUNCTION  <SNR>105_GetCounts()
    Defined: ~/.vim/vim-plug/ale/autoload/ale/statusline.vim:97
Called 11 times
Total time:   0.000945
 Self time:   0.000601

count  total (s)   self (s)
   11   0.000498   0.000322     if !s:BufferCacheExists(a:buffer)
   11   0.000430   0.000262         return s:CreateCountDict()
                                endif
                            
                                call s:UpdateCacheIfNecessary(a:buffer)
                            
                                return g:ale_buffer_info[a:buffer].count

FUNCTION  ale#statusline#Count()
    Defined: ~/.vim/vim-plug/ale/autoload/ale/statusline.vim:119
Called 11 times
Total time:   0.001364
 Self time:   0.000419

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
   11   0.001340   0.000395     return copy(s:GetCounts(a:buffer))

FUNCTION  <SNR>119_wrap()
    Defined: ~/.vim/vim-plug/fzf.vim/autoload/fzf/vim.vim:118
Called 2 times
Total time:   0.006305
 Self time:   0.000180

count  total (s)   self (s)
                              " fzf#wrap does not append --expect if sink or sink* is found
    2              0.000013   let opts = copy(a:opts)
    2              0.000004   let options = ''
    2              0.000007   if has_key(opts, 'options')
    2              0.000018     let options = type(opts.options) == s:TYPE.list ? join(opts.options) : opts.options
    2              0.000005   endif
    2              0.000020   if options !~ '--expect' && has_key(opts, 'sink*')
                                let Sink = remove(opts, 'sink*')
                                let wrapped = fzf#wrap(a:name, opts, a:bang)
                                let wrapped['sink*'] = Sink
    2              0.000001   else
    2   0.006198   0.000073     let wrapped = fzf#wrap(a:name, opts, a:bang)
    2              0.000002   endif
    2              0.000003   return wrapped

FUNCTION  <SNR>78_execute()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:574
Called 2 times
Total time:   1.951239
 Self time:   0.008074

count  total (s)   self (s)
    2   0.000890   0.000045   call s:pushd(a:dict)
    2              0.000007   if has('unix') && !a:use_height
                                silent! !clear 2> /dev/null
    2              0.000002   endif
    2              0.000013   let escaped = (a:use_height || s:is_win) ? a:command : escape(substitute(a:command, '\n', '\\n', 'g'), '%#!')
    2              0.000008   if has('gui_running')
                                let Launcher = get(a:dict, 'launcher', get(g:, 'Fzf_launcher', get(g:, 'fzf_launcher', s:launcher)))
                                let fmt = type(Launcher) == 2 ? call(Launcher, []) : Launcher
                                if has('unix')
                                  let escaped = "'".substitute(escaped, "'", "'\"'\"'", 'g')."'"
                                endif
                                let command = printf(fmt, escaped)
    2              0.000001   else
    2              0.000004     let command = escaped
    2              0.000002   endif
    2              0.000002   if s:is_win
                                let batchfile = s:fzf_tempname().'.bat'
                                call writefile(s:wrap_cmds(command), batchfile)
                                let command = batchfile
                                let a:temps.batchfile = batchfile
                                if has('nvim')
                                  let fzf = {}
                                  let fzf.dict = a:dict
                                  let fzf.temps = a:temps
                                  function! fzf.on_exit(job_id, exit_status, event) dict
                                    call s:pushd(self.dict)
                                    let lines = s:collect(self.temps)
                                    call s:callback(self.dict, lines)
                                  endfunction
                                  let cmd = 'start /wait cmd /c '.command
                                  call jobstart(cmd, fzf)
                                  return []
                                endif
    2              0.000009   elseif has('win32unix') && $TERM !=# 'cygwin'
                                let shellscript = s:fzf_tempname()
                                call writefile([command], shellscript)
                                let command = 'cmd.exe /C '.fzf#shellescape('set "TERM=" & start /WAIT sh -c '.shellscript)
                                let a:temps.shellscript = shellscript
    2              0.000002   endif
    2              0.000002   if a:use_height
    2              0.000007     let stdin = has_key(a:dict, 'source') ? '' : '< /dev/tty'
    2   1.942869   0.000570     call system(printf('tput cup %d > /dev/tty; tput cnorm > /dev/tty; %s %s 2> /dev/tty', &lines, command, stdin))
                              else
                                execute 'silent !'.command
    2              0.000002   endif
    2              0.000014   let exit_status = v:shell_error
    2              0.007146   redraw!
    2   0.000119   0.000098   return s:exit_handler(exit_status, command) ? s:collect(a:temps) : []

FUNCTION  <SNR>119_extend_opts()
    Defined: ~/.vim/vim-plug/fzf.vim/autoload/fzf/vim.vim:49
Called 2 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    2              0.000019   if empty(a:eopts)
    2              0.000004     return
                              endif
                              if has_key(a:dict, 'options')
                                if type(a:dict.options) == s:TYPE.list && type(a:eopts) == s:TYPE.list
                                  if a:prepend
                                    let a:dict.options = extend(copy(a:eopts), a:dict.options)
                                  else
                                    call extend(a:dict.options, a:eopts)
                                  endif
                                else
                                  let all_opts = a:prepend ? [a:eopts, a:dict.options] : [a:dict.options, a:eopts]
                                  let a:dict.options = join(map(all_opts, 'type(v:val) == s:TYPE.list ? join(map(copy(v:val), "fzf#shellescape(v:val)")) : v:val'))
                                endif
                              else
                                let a:dict.options = a:eopts
                              endif

FUNCTION  <SNR>78_get_color()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:277
Called 26 times
Total time:   0.003079
 Self time:   0.003079

count  total (s)   self (s)
   26              0.000545   let gui = !s:is_win && !has('win32unix') && has('termguicolors') && &termguicolors
   26              0.000063   let fam = gui ? 'gui' : 'cterm'
   26              0.000050   let pat = gui ? '^#[a-f0-9]\+' : '^[0-9]\+$'
   30              0.000123   for group in a:000
   30              0.001335     let code = synIDattr(synIDtrans(hlID(group)), a:attr, fam)
   30              0.000614     if code =~? pat
   26              0.000049       return code
    4              0.000018     endif
    4              0.000012   endfor
                              return ''

FUNCTION  lightline#mode()
    Defined: ~/.vim/vim-plug/lightline.vim/autoload/lightline.vim:212
Called 22 times
Total time:   0.000265
 Self time:   0.000265

count  total (s)   self (s)
   22              0.000238   return get(s:lightline.mode_map, mode(), '')

FUNCTION  <SNR>78_dopopd()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:515
Called 2 times
Total time:   0.000531
 Self time:   0.000457

count  total (s)   self (s)
    2              0.000009   if !exists('w:fzf_pushd')
                                return
    2              0.000001   endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
    2   0.000102   0.000047   if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
    2   0.000376   0.000357     execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
    2              0.000004   endif
    2              0.000018   unlet w:fzf_pushd

FUNCTION  <SNR>78_common_sink()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:239
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000012   if len(a:lines) < 2
    2              0.000003     return
                              endif
                              let key = remove(a:lines, 0)
                              let Cmd = get(a:action, key, 'e')
                              if type(Cmd) == type(function('call'))
                                return Cmd(a:lines)
                              endif
                              if len(a:lines) > 1
                                augroup fzf_swap
                                  autocmd SwapExists * let v:swapchoice='o'| call s:warn('fzf: E325: swap file exists: '.s:fzf_expand('<afile>'))
                                augroup END
                              endif
                              try
                                let empty = empty(s:fzf_expand('%')) && line('$') == 1 && empty(getline(1)) && !&modified
                                let autochdir = &autochdir
                                set noautochdir
                                for item in a:lines
                                  if empty
                                    execute 'e' s:escape(item)
                                    let empty = 0
                                  else
                                    call s:open(Cmd, item)
                                  endif
                                  if !has('patch-8.0.0177') && !has('nvim-0.2') && exists('#BufEnter') && isdirectory(item)
                                    doautocmd BufEnter
                                  endif
                                endfor
                              catch /^Vim:Interrupt$/
                              finally
                                let &autochdir = autochdir
                                silent! autocmd! fzf_swap
                              endtry

FUNCTION  LightlineFilename()
    Defined: ~/.vim/conf/lightline.vim:151
Called 22 times
Total time:   0.002802
 Self time:   0.002128

count  total (s)   self (s)
   22              0.000129   let fname = expand('%:t')
   22   0.002625   0.001951   return fname == 'ControlP' && has_key(g:lightline, 'ctrlp_item') ? g:lightline.ctrlp_item : fname == '__Tagbar__' ? g:lightline.fname : fname =~ '__Gundo\|NERD_tree' ? '' : &ft == 'vimfiler' ? vimfiler#get_status_string() : &ft == 'unite' ? unite#get_status_string() : &ft == 'vimshell' ? vimshell#get_status_string() : ('' != LightlineReadonly() ? LightlineReadonly() . ' ' : '') . ('' != fname ? (winwidth(0) > 115 ? expand('%') : expand('%:t')) : '[No Name]') . ('' != LightlineModified() ? ' ' . LightlineModified() : '')

FUNCTION  <SNR>78_calc_size()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:639
Called 2 times
Total time:   0.000234
 Self time:   0.000210

count  total (s)   self (s)
    2              0.000027   let val = substitute(a:val, '^\~', '', '')
    2              0.000009   if val =~ '%$'
    2              0.000020     let size = a:max * str2nr(val[:-2]) / 100
                              else
                                let size = min([a:max, str2nr(val)])
    2              0.000002   endif
                            
    2              0.000003   let srcsz = -1
    2              0.000015   if type(get(a:dict, 'source', 0)) == type([])
                                let srcsz = len(a:dict.source)
    2              0.000001   endif
                            
    2   0.000091   0.000067   let opts = $FZF_DEFAULT_OPTS.' '.s:evaluate_opts(get(a:dict, 'options', ''))
    2              0.000012   let margin = stridx(opts, '--inline-info') > stridx(opts, '--no-inline-info') ? 1 : 2
    2              0.000011   let margin += stridx(opts, '--border') > stridx(opts, '--no-border') ? 2 : 0
    2              0.000008   let margin += stridx(opts, '--header') > stridx(opts, '--no-header')
    2              0.000006   return srcsz >= 0 ? min([srcsz + margin, size]) : size

FUNCTION  fzf#wrap()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:312
Called 2 times
Total time:   0.006125
 Self time:   0.001096

count  total (s)   self (s)
    2              0.000035   let args = ['', {}, 0]
    2              0.000109   let expects = map(copy(args), 'type(v:val)')
    2              0.000033   let tidx = 0
    8              0.000091   for arg in copy(a:000)
    6              0.000045     let tidx = index(expects, type(arg), tidx)
    6              0.000016     if tidx < 0
                                  throw 'Invalid arguments (expected: [name string] [opts dict] [fullscreen boolean])'
    6              0.000011     endif
    6              0.000035     let args[tidx] = arg
    6              0.000020     let tidx += 1
    6              0.000015     unlet arg
    8              0.000011   endfor
    2              0.000008   let [name, opts, bang] = args
                            
    2              0.000007   if len(name)
    2              0.000006     let opts.name = name
    2              0.000002   end
                            
                              " Layout: g:fzf_layout (and deprecated g:fzf_height)
    2              0.000001   if bang
                                for key in s:layout_keys
                                  if has_key(opts, key)
                                    call remove(opts, key)
                                  endif
                                endfor
    2   0.000197   0.000094   elseif !s:has_any(opts, s:layout_keys)
    2              0.000015     if !exists('g:fzf_layout') && exists('g:fzf_height')
                                  let opts.down = g:fzf_height
    2              0.000002     else
    2   0.000126   0.000073       let opts = extend(opts, s:validate_layout(get(g:, 'fzf_layout', s:default_layout)))
    2              0.000002     endif
    2              0.000000   endif
                            
                              " Colors: g:fzf_colors
    2   0.004933   0.000136   let opts.options = s:defaults() .' '. s:evaluate_opts(get(opts, 'options', ''))
                            
                              " History: g:fzf_history_dir
    2              0.000019   if len(name) && len(get(g:, 'fzf_history_dir', ''))
                                let dir = s:fzf_expand(g:fzf_history_dir)
                                if !isdirectory(dir)
                                  call mkdir(dir, 'p')
                                endif
                                let history = fzf#shellescape(dir.'/'.name)
                                let opts.options = join(['--history', history, opts.options])
    2              0.000001   endif
                            
                              " Action: g:fzf_action
    2   0.000127   0.000051   if !s:has_any(opts, ['sink', 'sink*'])
    2              0.000030     let opts._action = get(g:, 'fzf_action', s:default_action)
    2              0.000026     let opts.options .= ' --expect='.join(keys(opts._action), ',')
    2              0.000008     function! opts.sink(lines) abort
                                  return s:common_sink(self._action, a:lines)
                                endfunction
    2              0.000017     let opts['sink*'] = remove(opts, 'sink')
    2              0.000003   endif
                            
    2              0.000003   return opts

FUNCTION  fzf#shellescape()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:94
Called 4 times
Total time:   0.000264
 Self time:   0.000222

count  total (s)   self (s)
    4              0.000042   let shell = get(a:000, 0, s:is_win ? 'cmd.exe' : 'sh')
    4              0.000032   if shell =~# 'cmd.exe$'
                                return s:shellesc_cmd(a:arg)
    4              0.000004   endif
    4   0.000163   0.000121   return s:fzf_call('shellescape', a:arg)

FUNCTION  LightlineAle()
    Defined: ~/.vim/conf/lightline.vim:144
Called 11 times
Total time:   0.001900
 Self time:   0.000536

count  total (s)   self (s)
   11   0.001741   0.000377   let counts = ale#statusline#Count(bufnr(''))
   11              0.000048   let errors = counts.error > 0 ? 'E:'.counts.error : ''
   11              0.000047   let warnings = counts.warning > 0 ? (errors !=# '' ? ' W:'.counts.warning : 'W:'.counts.warning) : ''
   11              0.000038   return errors.warnings

FUNCTION  <SNR>78_fzf_call()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:73
Called 12 times
Total time:   0.000293
 Self time:   0.000293

count  total (s)   self (s)
   12              0.000284     return call(a:fn, a:000)

FUNCTION  LightlineFiletype()
    Defined: ~/.vim/conf/lightline.vim:132
Called 22 times
Total time:   0.000156
 Self time:   0.000156

count  total (s)   self (s)
   22              0.000136   return winwidth(0) > 160 ? (&filetype !=# '' ? &filetype : 'no ft') : ''

FUNCTION  <SNR>78_escape()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:191
Called 4 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    4              0.000027   let path = fnameescape(a:path)
    4              0.000015   return s:is_win ? escape(path, '$') : path

FUNCTION  <SNR>78_pushd()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:493
Called 2 times
Total time:   0.000845
 Self time:   0.000498

count  total (s)   self (s)
    2   0.000133   0.000094   if s:present(a:dict, 'dir')
    2   0.000269   0.000040     let cwd = s:fzf_getcwd()
    2              0.000041     let w:fzf_pushd = {   'command': haslocaldir() ? 'lcd' : (exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd'),   'origin': cwd,   'bufname': bufname('') }
    2   0.000280   0.000251     execute 'lcd' s:escape(a:dict.dir)
    2   0.000100   0.000050     let cwd = s:fzf_getcwd()
    2              0.000005     let w:fzf_pushd.dir = cwd
    2              0.000006     let a:dict.pushd = w:fzf_pushd
    2              0.000002     return cwd
                              endif
                              return ''

FUNCTION  sy#repo#get_stats()
    Defined: ~/.vim/vim-plug/vim-signify/autoload/sy/repo.vim:232
Called 22 times
Total time:   0.000450
 Self time:   0.000450

count  total (s)   self (s)
   22              0.000304   let sy = getbufvar(a:0 ? a:1 : bufnr(''), 'sy')
   22              0.000126   return empty(sy) ? [-1, -1, -1] : sy.stats

FUNCTION  <SNR>78_evaluate_opts()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:306
Called 6 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
    6              0.000069   return type(a:options) == type([]) ? join(map(copy(a:options), 'fzf#shellescape(v:val)')) : a:options

FUNCTION  <SNR>105_CreateCountDict()
    Defined: ~/.vim/vim-plug/ale/autoload/ale/statusline.vim:5
Called 11 times
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
   11              0.000140     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  LightlineMode()
    Defined: ~/.vim/conf/lightline.vim:103
Called 22 times
Total time:   0.001872
 Self time:   0.001607

count  total (s)   self (s)
   22              0.000145   let fname = expand('%:t')
   22   0.001689   0.001424   return fname == '__Tagbar__' ? 'Tagbar' : fname == 'ControlP' ? 'CtrlP' : fname == '__Gundo__' ? 'Gundo' : fname == '__Gundo_Preview__' ? 'Gundo Preview' : fname =~ 'NERD_tree' ? 'NERDTree' : &ft == 'unite' ? 'Unite' : &ft == 'vimfiler' ? 'VimFiler' : &ft == 'vimshell' ? 'VimShell' : winwidth(0) > 60 ? lightline#mode() : ''

FUNCTION  <SNR>78_defaults()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:290
Called 2 times
Total time:   0.004764
 Self time:   0.001508

count  total (s)   self (s)
    2              0.000027   let rules = copy(get(g:, 'fzf_colors', {}))
    2   0.004506   0.001427   let colors = join(map(items(filter(map(rules, 'call("s:get_color", v:val)'), '!empty(v:val)')), 'join(v:val, ":")'), ',')
    2   0.000229   0.000052   return empty(colors) ? '' : fzf#shellescape('--color='.colors)

FUNCTION  <SNR>78_fzf_exec()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:158
Called 2 times
Total time:   0.000153
 Self time:   0.000066

count  total (s)   self (s)
    2              0.000007   if !exists('s:exec')
                                if executable(s:fzf_go)
                                  let s:exec = s:fzf_go
                                elseif executable('fzf')
                                  let s:exec = 'fzf'
                                elseif s:download_bin()
                                  return s:fzf_exec()
                                else
                                  redraw
                                  throw 'fzf executable not found'
                                endif
    2              0.000002   endif
    2   0.000115   0.000028   return fzf#shellescape(s:exec)

FUNCTION  <SNR>105_BufferCacheExists()
    Defined: ~/.vim/vim-plug/ale/autoload/ale/statusline.vim:88
Called 11 times
Total time:   0.000176
 Self time:   0.000176

count  total (s)   self (s)
   11              0.000133     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
   11              0.000021         return 0
                                endif
                            
                                return 1

FUNCTION  <SNR>78_fzf_getcwd()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:102
Called 6 times
Total time:   0.000334
 Self time:   0.000112

count  total (s)   self (s)
    6   0.000332   0.000110   return s:fzf_call('getcwd')

FUNCTION  LightlineReadonly()
    Defined: ~/.vim/conf/lightline.vim:57
Called 22 times
Total time:   0.000406
 Self time:   0.000406

count  total (s)   self (s)
   22              0.000389   return &readonly ? '' : ''

FUNCTION  LightlineModified()
    Defined: ~/.vim/conf/lightline.vim:140
Called 22 times
Total time:   0.000268
 Self time:   0.000268

count  total (s)   self (s)
   22              0.000145   return winwidth(0) > 70 ? (&modified > 0 ? '[+]' : '') : ''

FUNCTION  fzf#vim#gitfiles()
    Defined: ~/.vim/vim-plug/fzf.vim/autoload/fzf/vim.vim:536
Called 2 times
Total time:   2.007770
 Self time:   0.000252

count  total (s)   self (s)
    2   0.046192   0.000090   let root = s:get_git_root()
    2              0.000008   if empty(root)
                                return s:warn('Not in git repo')
    2              0.000002   endif
    2              0.000007   if a:args != '?'
    2   1.961542   0.000126     return s:fzf('gfiles', { 'source':  'git ls-files '.a:args.(s:is_win ? '' : ' | uniq'), 'dir':     root, 'options': '-m --prompt "GitFiles> "'}, a:000)
                              endif
                            
                              " Here be dragons!
                              " We're trying to access the common sink function that fzf#wrap injects to
                              " the options dictionary.
                              let wrapped = fzf#wrap({ 'source':  'git -c color.status=always status --short --untracked-files=all', 'dir':     root, 'options': ['--ansi', '--multi', '--nth', '2..,..', '--tiebreak=index', '--prompt', 'GitFiles?> ', '--preview', 'sh -c "(git diff --color=always -- {-1} | sed 1,4d; cat {-1}) | head -500"']})
                              call s:remove_layout(wrapped)
                              let wrapped.common_sink = remove(wrapped, 'sink*')
                              function! wrapped.newsink(lines)
                                let lines = extend(a:lines[0:0], map(a:lines[1:], 'substitute(v:val[3:], ".* -> ", "", "")'))
                                return self.common_sink(lines)
                              endfunction
                              let wrapped['sink*'] = remove(wrapped, 'newsink')
                              return s:fzf('gfiles-diff', wrapped, a:000)

FUNCTION  <SNR>78_exit_handler()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:557
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000011   if a:code == 130
    2              0.000003     return 0
                              elseif has('nvim') && a:code == 129
                                " When deleting the terminal buffer while fzf is still running,
                                " Nvim sends SIGHUP.
                                return 0
                              elseif a:code > 1
                                call s:error('Error running ' . a:command)
                                if !empty(a:000)
                                  sleep
                                endif
                                return 0
                              endif
                              return 1

FUNCTION  <SNR>78_callback()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:795
Called 2 times
Total time:   0.000921
 Self time:   0.000294

count  total (s)   self (s)
    2              0.000021   let popd = has_key(a:dict, 'pushd')
    2              0.000004   if popd
    2              0.000013     let w:fzf_pushd = a:dict.pushd
    2              0.000066   endif
                            
    2              0.000004   try
    2              0.000016     if has_key(a:dict, 'sink')
                                  for line in a:lines
                                    if type(a:dict.sink) == 2
                                      call a:dict.sink(line)
                                    else
                                      execute a:dict.sink s:escape(line)
                                    endif
                                  endfor
    2              0.000002     endif
    2              0.000007     if has_key(a:dict, 'sink*')
    2   0.000125   0.000029       call a:dict['sink*'](a:lines)
    2              0.000001     endif
                              catch
                                if stridx(v:exception, ':E325:') < 0
                                  echoerr v:exception
                                endif
    2              0.000005   endtry
                            
                              " We may have opened a new window or tab
    2              0.000004   if popd
    2              0.000007     let w:fzf_pushd = a:dict.pushd
    2   0.000566   0.000035     call s:dopopd()
    2              0.000004   endif

FUNCTION  <SNR>78_fzf_tempname()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:114
Called 2 times
Total time:   0.000065
 Self time:   0.000036

count  total (s)   self (s)
    2   0.000063   0.000034   return s:fzf_call('tempname')

FUNCTION  fzf#run()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:385
Called 2 times
Total time:   1.954599
 Self time:   0.001687

count  total (s)   self (s)
    2              0.000004 try
    2   0.000170   0.000052   let [shell, shellslash, shellcmdflag, shellxquote] = s:use_sh()
                            
    2   0.000164   0.000085   let dict   = exists('a:1') ? s:upgrade(a:1) : {}
    2   0.000134   0.000069   let temps  = { 'result': s:fzf_tempname() }
    2   0.000066   0.000045   let optstr = s:evaluate_opts(get(dict, 'options', ''))
    2              0.000002   try
    2   0.000190   0.000037     let fzf_exec = s:fzf_exec()
                              catch
                                throw v:exception
    2              0.000002   endtry
                            
    2              0.000007   if !has_key(dict, 'dir')
                                let dict.dir = s:fzf_getcwd()
    2              0.000001   endif
    2              0.000012   if has('win32unix') && has_key(dict, 'dir')
                                let dict.dir = fnamemodify(dict.dir, ':p')
    2              0.000002   endif
                            
    2              0.000009   if !has_key(dict, 'source') && !empty($FZF_DEFAULT_COMMAND) && !s:is_win
                                let temps.source = s:fzf_tempname()
                                call writefile(s:wrap_cmds(split($FZF_DEFAULT_COMMAND, "\n")), temps.source)
                                let dict.source = (empty($SHELL) ? &shell : $SHELL).' '.fzf#shellescape(temps.source)
    2              0.000002   endif
                            
    2              0.000005   if has_key(dict, 'source')
    2              0.000004     let source = dict.source
    2              0.000005     let type = type(source)
    2              0.000003     if type == 1
    2              0.000005       let prefix = '( '.source.' )|'
                                elseif type == 3
                                  let temps.input = s:fzf_tempname()
                                  call writefile(map(source, '<SID>enc_to_cp(v:val)'), temps.input)
                                  let prefix = (s:is_win ? 'type ' : 'cat ').fzf#shellescape(temps.input).'|'
                                else
                                  throw 'Invalid source type'
    2              0.000001     endif
                              else
                                let prefix = ''
    2              0.000000   endif
                            
    2              0.000006   let prefer_tmux = get(g:, 'fzf_prefer_tmux', 0)
    2   0.000723   0.000641   let use_height = has_key(dict, 'down') && !has('gui_running') && !(has('nvim') || s:is_win || has('win32unix') || s:present(dict, 'up', 'left', 'right', 'window')) && executable('tput') && filereadable('/dev/tty')
    2              0.000037   let has_vim8_term = has('terminal') && has('patch-8.0.995')
    2              0.000038   let has_nvim_term = has('nvim-0.2.1') || has('nvim') && !s:is_win
    2              0.000042   let use_term = has_nvim_term || has_vim8_term && !has('win32unix') && (has('gui_running') || s:is_win || !use_height && s:present(dict, 'down', 'up', 'left', 'right', 'window'))
    2              0.000017   let use_tmux = (!use_height && !use_term || prefer_tmux) && !has('win32unix') && s:tmux_enabled() && s:splittable(dict)
    2              0.000004   if prefer_tmux && use_tmux
                                let use_height = 0
                                let use_term = 0
    2              0.000003   endif
    2              0.000002   if use_height
    2   0.000319   0.000085     let height = s:calc_size(&lines, dict.down, dict)
    2              0.000009     let optstr .= ' --height='.height
                              elseif use_term
                                let optstr .= ' --no-height'
    2              0.000002   endif
    2              0.000020   let command = prefix.(use_tmux ? s:fzf_tmux(dict) : fzf_exec).' '.optstr.' > '.temps.result
                            
    2              0.000003   if use_term
                                return s:execute_term(dict, command, temps)
    2              0.000002   endif
                            
    2   1.951356   0.000117   let lines = use_tmux ? s:execute_tmux(dict, command, temps) : s:execute(dict, command, use_height, temps)
    2   0.001008   0.000087   call s:callback(dict, lines)
    2              0.000006   return lines
    2              0.000010 finally
    2              0.000064   let [&shell, &shellslash, &shellcmdflag, &shellxquote] = [shell, shellslash, shellcmdflag, shellxquote]
    2              0.000005 endtry

FUNCTION  <SNR>78_use_sh()
    Defined: ~/.vim/vim-plug/fzf/plugin/fzf.vim:372
Called 2 times
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
    2              0.000019   let [shell, shellslash, shellcmdflag, shellxquote] = [&shell, &shellslash, &shellcmdflag, &shellxquote]
    2              0.000003   if s:is_win
                                set shell=cmd.exe
                                set noshellslash
                                let &shellcmdflag = has('nvim') ? '/s /c' : '/c'
                                let &shellxquote = has('nvim') ? '"' : '('
    2              0.000003   else
    2              0.000058     set shell=sh
    2              0.000005   endif
    2              0.000009   return [shell, shellslash, shellcmdflag, shellxquote]

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    2   2.007770   0.000252  fzf#vim#gitfiles()
    2   1.961416   0.000406  <SNR>119_fzf()
    2   1.954599   0.001687  fzf#run()
    2   1.951239   0.008074  <SNR>78_execute()
    2   0.046102   0.000822  <SNR>119_get_git_root()
    2   0.006305   0.000180  <SNR>119_wrap()
    2   0.006125   0.001096  fzf#wrap()
    2   0.004764   0.001508  <SNR>78_defaults()
   26   0.003079             <SNR>78_get_color()
   22   0.002802   0.002128  LightlineFilename()
   22   0.002171   0.001721  LightlineHunks()
   11   0.001900   0.000536  LightlineAle()
   22   0.001872   0.001607  LightlineMode()
    3   0.001640   0.000539  sy#start()
   11   0.001364   0.000419  ale#statusline#Count()
   11   0.001357             lightline#link()
   11   0.000945   0.000601  <SNR>105_GetCounts()
    2   0.000921   0.000294  <SNR>78_callback()
    2   0.000845   0.000498  <SNR>78_pushd()
    3   0.000783             <SNR>109_get_path()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    2   1.951239   0.008074  <SNR>78_execute()
   26              0.003079  <SNR>78_get_color()
   22   0.002802   0.002128  LightlineFilename()
   22   0.002171   0.001721  LightlineHunks()
    2   1.954599   0.001687  fzf#run()
   22   0.001872   0.001607  LightlineMode()
    2   0.004764   0.001508  <SNR>78_defaults()
   11              0.001357  lightline#link()
    2   0.006125   0.001096  fzf#wrap()
    2   0.046102   0.000822  <SNR>119_get_git_root()
    3              0.000783  <SNR>109_get_path()
   11   0.000945   0.000601  <SNR>105_GetCounts()
    3   0.001640   0.000539  sy#start()
   11   0.001900   0.000536  LightlineAle()
    2   0.000845   0.000498  <SNR>78_pushd()
    2   0.000531   0.000457  <SNR>78_dopopd()
   22              0.000450  sy#repo#get_stats()
   11   0.001364   0.000419  ale#statusline#Count()
    2   1.961416   0.000406  <SNR>119_fzf()
   22              0.000406  LightlineReadonly()

